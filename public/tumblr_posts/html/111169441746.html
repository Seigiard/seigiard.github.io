        <!DOCTYPE HTML>
        <html>
            <head>
                <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
                <link rel="stylesheet" type="text/css" href="../style.css"/>
            </head>
            <body>
                
                
                                    <h1>Тернистый путь e2e-тестирования angular-приложения</h1>
                    <p>На работе осенью прошлого года за два месяца запустили проект, как proof-of-concept. В результате работы получили большого клиента и необходимость продолжить разработку.</p><p>Также было принято волевое решение покрыть проект тестами, потому что проект плавно приближался к точке невозврата, когда количество кода уже невозможно удержать в голове. Тесты — только e2e, потому что все рассчеты делаются на сервере, а приложение только гоняет данные туда-сюда и показывает красиво пользователю.</p><p>Для тестов выбрал <code>protractor</code>, естественно. Подключил через <code>grunt</code>, накатали пару тестов — все работает, лепота! Начал покрывать тестами страницу за страницей и началось самое интересное.</p><p>Во-первых, везде нужно входить в систему, т.к. у нас приложение с уровнями доступа. Пишем класс <code>LoginPage()</code> с методом <code>.login()</code> и вызываем его перед каждым тестом. Решили.</p><p>Во-вторых, везде нужно выходить, потому что тест на неправильную авторизацию валится, если предыдущий тест залогинился в систему. Добавили в <code>LoginPage()</code> метод <code>.logout()</code>. Помучались с определением, есть ли кнопка логаута или нет. Запустили тесты. Все упало.</p><p>Полдня заняли попытки понять, в чем дело. Дело оказалось в запросах к серверу, которые не перехватывались сервером. В результате у нас в приложении над кнопкой логаута всплывает уведомление об ошибке, а Селениум сходит с ума, не найдя по координатам нужную точку и закрывает браузер, попутно сваливая все тесты.</p><p>Хорошо. Значит надо перехватывать все запросы, чтобы таких ошибок больше не было. Я использую удобную библиотеку <code>protractor-http-mock</code>, которая позволяет легко это сделать. Но есть одно «но»&hellip;</p><p>«Мочить» запросы можно только одним вызовом функции <code>mock()</code>, передавая внутрь массив нужных запросов. Т.е. в разных классах объявить нужные моки не получится, надо все собирать централизованно.</p><p>В результате написал уберкласс <code>Pages()</code>, который умеет собирать массив моков. От него наследуются все остальные классы страниц. </p><p>При инициализации класса страницы категорий, в его собиратель моков передаются нужные моки. После чего, при запуске тестов для категорий, автоматически внутри класса категорий создается класс логина, куда передаются моки категорий, а логин уже окончательно мочит все запросы и делает автологин. Страница категорий редиректит браузер на нужный адрес и тесты начинают свою работу.</p><p>Получилась достаточно простая система работы, которая позволяет писать тесты под наше приложение. </p><p>Посмотрим, какие ещё интересные сюрпризы меня ждут.</p>
                
                
                
                
                
                
                                <div id="footer">
                <span id="timestamp"> February 16th, 2015 6:27am </span>
                                </div>
            </body>
        </html>

        